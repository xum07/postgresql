checkpoint即检查点，它本质上是一种精细化管理redo_log的手段，即通过在redo_log中分段加标记的方式，减少使用redo_log回放过程中需要处理的日志量。这是checkpoint的第一性

# 如何理解checkpoint机制

建立在上面的认识上，接下看下checkpoint机制怎么来实现这件事。先抛开checkpoint机制本身不谈，假设我们自身在面临*redo_log回放时需要处理大量日志*这个问题时，我们自己可以想到的办法是什么

首先：redo_log回放只所以需要处理大量日志，是因为它不知道回放到哪里需要停下来，只能从出异常的位置一直往前回放。所以需要有个标记告诉redo_log应该停下来的位置

那么就面临以下几个问题：

1. 这个标记可以直接放在redo_log里，当回放redo_log的时候遇到，就能知道；这个标记也可以放在与redo_log无关的位置，或者单独使用一个文件
2. 这个标记应该尽量选择一个合适的时间间隔，以及一个合适的数据量间隔。因为数据库有时候会面临长时间没什么业务，有时候又会短时间内业务量爆发
3. 这个标记里面应该携带一定的信息，除了方便redo_log回放处理，还得方便真出问题的时候，能够有效的定位
4. 既然是用于redo_log回放，就不应该只考虑单机的情况，备机build、备机追赶主机也是redo_log回放的一种场景

> 个人理解主要应该解决的是以上4个问题，其实除了这些，checkpoint机制还考虑了更多的问题，比如是不是应该做成手动命令，对用户提供sql支持等。这种我们先抛开不看，因为这对我们理解checkpoint的核心机制或者需要解决的核心问题并无影响

首先我们可以回答问题1，这个问题最为简单，答案是一目了然的：标记应该直接放在redo_log中。原因有几点：

1. redo_log这个机制本身就是为了记录对数据库系统有修改或者有影响的操作，而checkpoint其实也是其中一种。复用redo_log自身的机制是理所当然的，不然就是redo_log机制不称职（或者在redo_log之外搞出了其它特殊化的东西，这从设计上来说就很不好，而且不便于后续的扩展和维护）
2. redo_log已有的机制也方便checkpoint的使用，复用已有流程减轻工作量
3. PG的主备流复制采用的是redo_log（即问题4），如果弄出一个与redo_log无关的标记，反而增加流复制的处理逻辑

解决了问题1，下面我们再详细结合PG的源码来看下，PG是如何解决剩下的几个问题的

# checkpoint实现



## 不只是一个标记



## 需要一个常驻进程



## 怎么参与回放

